//! Type definitions for production agent

use serde::{Deserialize, Serialize};
use smallvec::SmallVec;

/// Agent state
#[derive(Debug, Clone)]
pub struct AgentState {
    /// Current conversation ID
    pub conversation_id: Option<String>,
    /// Message history
    pub messages: Vec<Message>,
    /// User context
    pub user_id: Option<String>,
    /// Session ID
    pub session_id: Option<String>,
    /// Current version for optimistic concurrency
    pub version: Option<composable_rust_core::stream::Version>,
    /// Last error (if any)
    pub last_error: Option<String>,
}

impl Default for AgentState {
    fn default() -> Self {
        Self::new()
    }
}

impl AgentState {
    /// Create new agent state
    #[must_use]
    pub const fn new() -> Self {
        Self {
            conversation_id: None,
            messages: Vec::new(),
            user_id: None,
            session_id: None,
            version: None,
            last_error: None,
        }
    }
}

/// Message in conversation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Message {
    /// Message role
    pub role: Role,
    /// Message content
    pub content: String,
    /// Timestamp
    pub timestamp: String,
}

/// Message role
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum Role {
    /// User message
    User,
    /// Assistant message
    Assistant,
    /// System message
    System,
}

/// Agent actions (commands and events)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AgentAction {
    // ========== Commands ==========
    /// Start new conversation (command)
    StartConversation {
        /// User ID
        user_id: String,
        /// Session ID
        session_id: String,
    },
    /// Send user message (command)
    SendMessage {
        /// Message content
        content: String,
        /// Source IP
        source_ip: Option<String>,
    },
    /// Process LLM response (command)
    ProcessResponse {
        /// Response text
        response: String,
    },
    /// Execute tool (command)
    ExecuteTool {
        /// Tool name
        tool_name: String,
        /// Tool input
        input: String,
    },
    /// End conversation (command)
    EndConversation,

    // ========== Events ==========
    /// Conversation started (event)
    ConversationStarted {
        /// Conversation ID
        conversation_id: String,
        /// User ID
        user_id: String,
        /// Session ID
        session_id: String,
        /// Timestamp
        timestamp: String,
    },
    /// Message received from user (event)
    MessageReceived {
        /// Message content
        content: String,
        /// Timestamp
        timestamp: String,
    },
    /// Response generated by LLM (event)
    ResponseGenerated {
        /// Response text
        response: String,
        /// Timestamp
        timestamp: String,
    },
    /// Tool executed (event)
    ToolExecuted {
        /// Tool name
        tool_name: String,
        /// Tool result
        result: Result<String, String>,
        /// Timestamp
        timestamp: String,
    },
    /// Conversation ended (event)
    ConversationEnded {
        /// Timestamp
        timestamp: String,
    },
    /// Security event detected (event)
    SecurityEventDetected {
        /// Event type
        event_type: String,
        /// Source
        source: String,
        /// Timestamp
        timestamp: String,
    },

    // ========== Internal Actions ==========
    /// Event was persisted successfully
    EventPersisted {
        /// The event that was persisted
        event: Box<AgentAction>,
        /// Version number
        version: u64,
    },
    /// Validation failed
    ValidationFailed {
        /// Error message
        error: String,
    },
}

impl AgentAction {
    /// Get the event type name for this action
    #[must_use]
    pub const fn event_type(&self) -> &'static str {
        match self {
            // Commands
            Self::StartConversation { .. } => "StartConversation",
            Self::SendMessage { .. } => "SendMessage",
            Self::ProcessResponse { .. } => "ProcessResponse",
            Self::ExecuteTool { .. } => "ExecuteTool",
            Self::EndConversation => "EndConversation",
            // Events
            Self::ConversationStarted { .. } => "ConversationStarted",
            Self::MessageReceived { .. } => "MessageReceived",
            Self::ResponseGenerated { .. } => "ResponseGenerated",
            Self::ToolExecuted { .. } => "ToolExecuted",
            Self::ConversationEnded { .. } => "ConversationEnded",
            Self::SecurityEventDetected { .. } => "SecurityEventDetected",
            // Internal
            Self::EventPersisted { .. } => "EventPersisted",
            Self::ValidationFailed { .. } => "ValidationFailed",
        }
    }
}

/// Agent environment
#[allow(dead_code)] // Demo example - not all trait methods used in basic example
pub trait AgentEnvironment: Send + Sync {
    /// Get event store
    fn event_store(&self) -> &std::sync::Arc<dyn composable_rust_core::event_store::EventStore>;

    /// Get clock
    fn clock(&self) -> &std::sync::Arc<dyn composable_rust_core::environment::Clock>;

    /// Get event bus
    fn event_bus(&self) -> &std::sync::Arc<dyn composable_rust_core::event_bus::EventBus>;

    /// Get projection store
    fn projection_store(&self) -> &std::sync::Arc<composable_rust_projections::PostgresProjectionStore>;

    /// Call LLM
    fn call_llm(
        &self,
        messages: &[Message],
    ) -> impl std::future::Future<Output = Result<String, AgentError>> + Send;

    /// Execute tool
    fn execute_tool(
        &self,
        tool_name: &str,
        input: &str,
    ) -> impl std::future::Future<Output = Result<String, AgentError>> + Send;

    /// Log audit event
    fn log_audit(
        &self,
        event_type: &str,
        actor: &str,
        action: &str,
        success: bool,
    ) -> impl std::future::Future<Output = Result<(), AgentError>> + Send;

    /// Report security incident
    fn report_security_incident(
        &self,
        incident_type: &str,
        source: &str,
        description: &str,
    ) -> impl std::future::Future<Output = Result<(), AgentError>> + Send;
}

/// Agent error
#[derive(Debug, thiserror::Error)]
#[allow(dead_code)] // Demo example - not all error variants used
pub enum AgentError {
    /// LLM error
    #[error("LLM error: {0}")]
    Llm(String),

    /// Tool execution error
    #[error("Tool execution error: {0}")]
    Tool(String),

    /// Invalid input
    #[error("Invalid input: {0}")]
    InvalidInput(String),

    /// Rate limited
    #[error("Rate limited")]
    RateLimited,

    /// Circuit breaker open
    #[error("Circuit breaker open")]
    CircuitBreakerOpen,

    /// Timeout
    #[error("Timeout")]
    Timeout,

    /// Audit error
    #[error("Audit error: {0}")]
    Audit(String),

    /// Security error
    #[error("Security error: {0}")]
    Security(String),
}

/// Effect type alias
pub type Effect = composable_rust_core::effect::Effect<AgentAction>;

/// Effects alias for SmallVec
pub type Effects = SmallVec<[Effect; 4]>;
